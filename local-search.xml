<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式（1）——单例模式</title>
    <link href="/2021/09/design-pattern-singleton/"/>
    <url>/2021/09/design-pattern-singleton/</url>
    
    <content type="html"><![CDATA[<p>单例模式(Singleton Pattern)<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式基于 classloader 机制避免了多线程的同步问题，会在第一次调用时就直接初始化，<strong>线程安全</strong>，但是可能会浪费空间。</p><p>可以在使用的时候再创建对象，于是出现了懒汉式。</p><pre><code>public class SingletonGreed &#123;    public SingletonGreed() &#123;    &#125;    private final static SingletonGreed SINGLETON = new SingletonGreed();    public static SingletonGreed getInstance() &#123;        return SINGLETON;    &#125;&#125;</code></pre><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式，并发下会出现重复创建对象的问题，<strong>线程不安全</strong>。</p><pre><code>public class SingletonLazy &#123;    public SingletonLazy() &#123;    &#125;    private static SingletonLazy SINGLETON;    public static SingletonLazy getInstance() &#123;        if (SINGLETON == null) &#123;            SINGLETON = new SingletonLazy();        &#125;        return SINGLETON;    &#125;</code></pre><h2 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h2><p>这里给懒汉式引入了双重检测锁(DCL, Double Checked Locking)，做到<strong>线程安全</strong>。</p><pre><code>public class SingletonLazy &#123;    public SingletonLazy() &#123;    &#125;    private volatile static SingletonLazy SINGLETON;    public static SingletonLazy getInstance() &#123;        if (SINGLETON == null) &#123;            synchronized (SingletonLazy.class) &#123;                if (SINGLETON == null) &#123;                    SINGLETON = new SingletonLazy();                &#125;            &#125;        &#125;        return SINGLETON;    &#125;&#125;</code></pre><p>其中由于 <code>SINGLETON = new SingletonLazy();</code> 不是原子性操作，分为以下三步：</p><ol><li>分配内存空间</li><li>执行构造函数，初始化对象</li><li>把对象指向这个空间<br>所以我们需要加上 <code>volatile</code> 关键字，防止指令重排。</li></ol><h3 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h3><p>懒汉式还有个问题是会被反射破坏掉单例状态，如下演示：</p><pre><code>SingletonLazy instance1 = SingletonLazy.getInstance();Constructor&lt;SingletonLazy&gt; declaredConstructor = SingletonLazy.class.getDeclaredConstructor(null);declaredConstructor.setAccessible(true);SingletonLazy instance2 = declaredConstructor.newInstance();System.out.println(instance1);System.out.println(instance2);</code></pre><p><img src="/images/16320685831860.jpg" alt=""></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类可以实现和双重检测锁一样<strong>线程安全</strong>的效果，实现起来更简单。</p><p>和上面的一样，这个也是不安全的，会被反射破坏单例。</p><pre><code>public class SingletonHolder &#123;    private SingletonHolder() &#123;    &#125;    public static class InnerClass &#123;        private static final SingletonHolder HOLDER = new SingletonHolder();    &#125;    public static SingletonHolder getInstance() &#123;        return InnerClass.HOLDER;    &#125;&#125;</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举可以很好的防止反射，同样也是<strong>线程安全</strong>的。</p><pre><code>public enum SingletonEnum &#123;    INSTANCE;    public SingletonEnum getInstance() &#123;        return INSTANCE;    &#125;&#125;</code></pre><h3 id="反射测试"><a href="#反射测试" class="headerlink" title="反射测试"></a>反射测试</h3><pre><code>SingletonEnum instance1 = SingletonEnum.INSTANCE;Constructor&lt;SingletonEnum&gt; declaredConstructor = SingletonEnum.class.getDeclaredConstructor(String.class, int.class);declaredConstructor.setAccessible(true);SingletonEnum instance2 = declaredConstructor.newInstance();System.out.println(instance1);System.out.println(instance2);</code></pre><p><img src="/images/16320691021882.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>design pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design pattern</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源镜像站点汇总</title>
    <link href="/2021/08/open-source-mirror-sites/"/>
    <url>/2021/08/open-source-mirror-sites/</url>
    
    <content type="html"><![CDATA[<h1 id="PyPi-镜像"><a href="#PyPi-镜像" class="headerlink" title="PyPi 镜像"></a>PyPi 镜像</h1><h2 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h2><p><code>pip install -i [url] [some-package]</code></p><h2 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h2><p><code>pip config set global.index-url [url]</code></p><h2 id="国内镜像地址"><a href="#国内镜像地址" class="headerlink" title="国内镜像地址"></a>国内镜像地址</h2><p>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>阿里：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p><p>豆瓣：<a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a></p><p>北京外国语大学：<a href="https://mirrors.bfsu.edu.cn/pypi/web/simple/">https://mirrors.bfsu.edu.cn/pypi/web/simple/</a></p><h1 id="nvm-镜像"><a href="#nvm-镜像" class="headerlink" title="nvm 镜像"></a>nvm 镜像</h1><h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><pre><code class="lang-bash">curl -sS -o- https://raw.fastgit.org/nvm-sh/nvm/master/install.sh | sed -e &quot;s/raw.githubusercontent.com/raw.fastgit.org/g&quot; | sed -e &quot;s/github.com/hub.fastgit.org/g&quot; | bash</code></pre><pre><code class="lang-bash">wget -qO- https://raw.fastgit.org/nvm-sh/nvm/master/install.sh | sed -e &quot;s/raw.githubusercontent.com/raw.fastgit.org/g&quot; | sed -e &quot;s/github.com/hub.fastgit.org/g&quot; | bash</code></pre><h2 id="nvm-镜像（安装node）"><a href="#nvm-镜像（安装node）" class="headerlink" title="nvm 镜像（安装node）"></a>nvm 镜像（安装node）</h2><pre><code>export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code></pre><h2 id="nvm-指定默认-node-版本"><a href="#nvm-指定默认-node-版本" class="headerlink" title="nvm 指定默认 node 版本"></a>nvm 指定默认 node 版本</h2><p><code>nvm alias default [node-version]</code></p><h1 id="npm-镜像"><a href="#npm-镜像" class="headerlink" title="npm 镜像"></a>npm 镜像</h1><h2 id="临时使用-1"><a href="#临时使用-1" class="headerlink" title="临时使用"></a>临时使用</h2><p><code>npm install [some-package] --registry [url]</code></p><h2 id="设为默认-1"><a href="#设为默认-1" class="headerlink" title="设为默认"></a>设为默认</h2><p><code>npm config set registry [url]</code></p><h2 id="国内镜像地址-1"><a href="#国内镜像地址-1" class="headerlink" title="国内镜像地址"></a>国内镜像地址</h2><p>淘宝：<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p><p>cnpmjs：<a href="https://r.cnpmjs.org">https://r.cnpmjs.org</a></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><pre><code class="lang-bash">curl -sSL https://dl.slw.im/docker_install.sh | sh</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开源软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在macOS上使用GPG对GitHub进行签名</title>
    <link href="/2020/09/submit-to-github-with-gpg-on-mac/"/>
    <url>/2020/09/submit-to-github-with-gpg-on-mac/</url>
    
    <content type="html"><![CDATA[<p>在GitHub上面我们对自己提交的commit进行签名，通过签名之后GitHub就会知道这个commit是经过签名的、可信的commit，并且会有个绿色的“Verified”显示在旁边。<br><img src="/images/pasted-8.png" alt="github pgp"></p><h1 id="安装PGP"><a href="#安装PGP" class="headerlink" title="安装PGP"></a>安装PGP</h1><p>这里通过homebrew进行安装，没有的话可以通过官网<a href="https://brew.sh/index_zh-cn">https://brew.sh/ </a>先安装homebrew。</p><p><code>brew install gpg</code></p><p>安装完成后可以通过<code>gpg --version</code>查看当前安装的GPG版本号。</p><h1 id="生成GPG秘钥"><a href="#生成GPG秘钥" class="headerlink" title="生成GPG秘钥"></a>生成GPG秘钥</h1><h2 id="GPG版本为2-1-17或者更高"><a href="#GPG版本为2-1-17或者更高" class="headerlink" title="GPG版本为2.1.17或者更高"></a>GPG版本为2.1.17或者更高</h2><p><code>gpg --full-generate-key</code></p><h2 id="GPG版本低于2-1-17"><a href="#GPG版本低于2-1-17" class="headerlink" title="GPG版本低于2.1.17"></a>GPG版本低于2.1.17</h2><p><code>gpg --default-new-key-algo rsa4096 --gen-key</code></p><h2 id="生成密钥时的参数"><a href="#生成密钥时的参数" class="headerlink" title="生成密钥时的参数"></a>生成密钥时的参数</h2><p>加密方式选择默认的：<code>RSA and DSA</code></p><p>秘钥长度：<code>4096</code></p><p>秘钥有效时间可以根据自己的喜好进行选择。</p><p>在输入用户信息的时候需要输入经过GitHub认证过的邮箱，可以通过连接 <a href="https://github.com/settings/emails">https://github.com/settings/emails</a> 查看。</p><p>接下来就是要输入验证的密码，这里可能会是乱码，但是不影响输入，这里一共需要输入两次密码。</p><h1 id="查看生成的秘钥"><a href="#查看生成的秘钥" class="headerlink" title="查看生成的秘钥"></a>查看生成的秘钥</h1><p>通过命令查看GPG秘钥的ID</p><p><code>gpg --list-secret-keys --keyid-format LONG</code></p><p>输出如下：</p><pre><code>$ gpg --list-secret-keys --keyid-format LONG/Users/hubot/.gnupg/secring.gpg------------------------------------sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]uid                          Hubot ssb   4096R/42B317FD4BA89E7A 2016-03-10</code></pre><p>这里的<code>3AA5C34371567BD2</code>就是我们需要的秘钥ID，接下来运行下面的命令，将其中的秘钥ID替换为自己的ID</p><p><code>gpg --armor --export 3AA5C34371567BD2</code></p><p>得到从 <code>-----BEGIN PGP PUBLIC KEY BLOCK-----</code> 开始到 <code>-----END PGP PUBLIC KEY BLOCK-----</code> 结束的公钥。</p><h1 id="添加GPG公钥至GitHub"><a href="#添加GPG公钥至GitHub" class="headerlink" title="添加GPG公钥至GitHub"></a>添加GPG公钥至GitHub</h1><p>打开GitHub的设置页面：<a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><p>点击 <code>New GPG key</code>，把刚刚得到的公钥粘贴进去。</p><p><img src="/images/pasted-9.png" alt="github gpg keys"></p><h1 id="设置git使用GPG秘钥"><a href="#设置git使用GPG秘钥" class="headerlink" title="设置git使用GPG秘钥"></a>设置git使用GPG秘钥</h1><p>运行命令，需要替换为自己的秘钥ID：</p><p><code>git config --global user.signingkey 3AA5C34371567BD2</code></p><p>如果只需要对当前仓库使用GPG秘钥：</p><p><code>git config commit.gpgsign true</code></p><p>如果需要对所有仓库使用GPG秘钥：</p><p><code>git config --global commit.gpgsign true</code></p><h1 id="提交报错"><a href="#提交报错" class="headerlink" title="提交报错"></a>提交报错</h1><p>这个时候如果进行commit，会遇到一下的错误：</p><pre><code>error: gpg failed to sign the data fatal: failed to write commit object</code></pre><p>经过查询，需要安装 pinentry-mac：</p><p><code>brew install pinentry-mac</code></p><p>然后在文件<code>~/.gnupg/gpg-agent.conf</code>中加入</p><pre><code>pinentry-program /usr/local/bin/pinentry-mac</code></pre><p>最后重启pinentry才能生效：<code>gpg-connect-agent reloadagent</code></p><p>这个时候再次进行commit，就可以正常输入密码提交了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://docs.github.com/en/github/authenticating-to-github/generating-a-new-gpg-key">Generating a new GPG key</a></li><li><a href="https://docs.github.com/en/github/authenticating-to-github/adding-a-new-gpg-key-to-your-github-account">Adding a new GPG key to your GitHub account</a></li><li><a href="https://docs.github.com/en/github/authenticating-to-github/telling-git-about-your-signing-key">Telling Git about your signing key</a></li><li><a href="https://presstige.io/p/GPG-424f30c6057f4e2e914c0f2e8fc22c72">Mac 下 配置 Git 使用 GPG</a></li><li><a href="https://morooi.cn/2020/github-gpg/">在 macOS 中使用 GPG 签名提交至 Github</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>gpg</tag>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法] leetcode 题型之 滑动窗口</title>
    <link href="/2020/05/leetcode-sliding-window/"/>
    <url>/2020/05/leetcode-sliding-window/</url>
    
    <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>滑动窗口是双指针的其中一种用法，在 leetcode 上面也是不时能看到它的身影。<br>滑动窗口的双指针分别代表的是窗口的左边界和右边界，而我们需要做的，就是在每次循环时，右边界向右移，同时，去判断窗口内的数据是否依旧满足题解，如果不满足，则需要将左边界也向右移。<br>因此，滑动指针的题目可以用类似以下的模板进行改动：</p><pre><code class="lang-c++">void slidingWindow(string s) &#123;    int left = 0, right = 0;    while (right &lt; s.size()) &#123;        // c 是窗口中新移入的字符        char c = s[right];        // 右边界右移        right++;        // 进行数据操作（如有）        doSomeWork();        while (windowTooLarge()) &#123;            // d 是窗口中将要移出的字符            char d = s[left];            // 左边界右移            left++;            // 进行数据操作（如有）            doAnotherWork();        &#125;    &#125;&#125;</code></pre><p>下面通过 leetcode 实战题来进一步说明如何使用这个模板。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode 76</a><br>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><pre><code>输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot;</code></pre><p>说明：</p><ul><li>如果 S 中不存这样的子串，则返回空字符串 “”。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="/images/pasted-2.png" alt="sliding window 1"></p><p>首先，我们有两个指针（在这里，我们用蓝色箭头代表左指针，黑色箭头代表右指针），分别指向开头；然后我们右边的指针不断右移，扩大当前窗口，直到所有字符串 T 中的字母都在窗口中出现。</p><p><img src="/images/pasted-3.png" alt="sliding window 2"></p><p>此时，需要将左指针右移，并记录满足题目条件时最小的窗口大小所对应的左指针和右指针。</p><p><img src="/images/pasted-4.png" alt="sliding window 3"></p><p>左指针右移后，发现不再满足题意，因此要将右指针右移至合适的位置。</p><p><img src="/images/pasted-5.png" alt="sliding window 4"></p><p>此时，窗口内的字符都包含字符串 T 中的字母了，需要移动左指针。</p><p><img src="/images/pasted-6.png" alt="sliding window 5"></p><p>以此类推，不断通过右指针扩大窗口至符合条件，左指针不断缩小窗口，直至不再满足题目条件。直到遍历完整个字符串，得到窗口最小的时候对应的左右指针的下标。</p><p><img src="/images/pasted-7.png" alt="sliding window 6"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-c++">class Solution &#123;public:    string minWindow(string s, string t) &#123;        unordered_map&lt;char, int&gt; need, window;        for (char c : t) need[c]++;        int left = 0, right = 0;        int valid = 0;        int start = 0, len = INT_MAX;         // len 赋值为极大值，如果所有字符都不满足，则输出空字符串        while (right &lt; s.size()) &#123;            // c 是将移入窗口的字符            char c = s[right];            // 右边界右移            right++;            // 进行窗口内数据的一系列更新            // 统计当前窗口中出现所需字母的次数            // 如果出现了所有字符，那么 valid == need.size()            if (need.count(c)) &#123;                window[c]++;                if (need[c] == window[c]) &#123;                    valid++;                &#125;            &#125;            // 判断左侧窗口是否要收缩            while (valid == need.size()) &#123;                if (right - left &lt; len) &#123;                    start = left;                    len = right - left;                &#125;                // d 是将移出窗口的字符                char d = s[left];                // 左移窗口                left++;                if (need.count(d)) &#123;                    if (need[d] == window[d]) &#123;                        valid--;                    &#125;                    window[d]--;                &#125;            &#125;        &#125;        return len == INT_MAX ? &quot;&quot; : s.substr(start, len);    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 GitHub Action 自动部署 Hexo</title>
    <link href="/2020/04/github-action-for-hexo/"/>
    <url>/2020/04/github-action-for-hexo/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/features/actions">Github Actions</a> 是Github官方推出的 CI/CD 工具，通过它，可以在每次提交代码时，自动编译并部署到 <a href="https://pages.github.com/">Github Pages</a>。这样就不用每次写好博客时，手工部署到服务器上。<br>Github Actions 针对公开仓库永久免费。当然，像博客这样的数据我们一般都是放在私有仓库里的，Github Actions 同样提供每月至少 2000 分钟的运行时长，这个时间对于博客的自动部署是足够了。</p><h1 id="生成Github-Personal-access-token"><a href="#生成Github-Personal-access-token" class="headerlink" title="生成Github Personal access token"></a>生成Github Personal access token</h1><p>在 Settings -&gt; Developer settings -&gt; <a href="https://github.com/settings/tokens">Personal access tokens</a> 中，点击 <code>Generate new token</code>，我们可以生成 token。在生成 token 时，我们要注意勾选上<code>repo</code>权限。需要注意的是，这里生成的token在关闭网页后就没法再次查看了，所以这里一定要保存好，在下一步中我们会用到这个 token。<br><img src="/images/pasted-0.png" alt="Personal access token"></p><h1 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h1><p>我们在这里用的是双仓库的形式，即仓库 A 存放 Hexo 源文件，仓库 B (xxx.github.io) 存放生成的部署文件。对仓库 A 进行 push 之后，会自动更新部署仓库 B。<br>我们需要在仓库 A 中的 Settings -&gt; Secrets -&gt; Add a new  secret 中添加我们刚刚生成的 token，名称 为<code>GITHUB_ACCESS_TOKEN</code>。<br><img src="/images/pasted-1.png" alt="secrets"></p><h1 id="配置-Hexo-的部署方式"><a href="#配置-Hexo-的部署方式" class="headerlink" title="配置 Hexo 的部署方式"></a>配置 Hexo 的部署方式</h1><p>修改 hexo 文件夹中的<code>_config.yml</code>，将下面代码中的<code>YOUR_GITHUB_USERNAME</code>和<code>YOUR_GITHUB_REPO</code>修改为自己的内容。</p><pre><code>deploy:- type: git  repo: https://GITHUB_ACCESS_TOKEN@github.com/YOUR_GITHUB_USERNAME/YOUR_GITHUB_REPO.git  branch: master</code></pre><h1 id="配置-Github-Actions"><a href="#配置-Github-Actions" class="headerlink" title="配置 Github Actions"></a>配置 Github Actions</h1><p>在 Hexo 根目录下新建<code>.github/workflow/blogci.yml</code>文件，修改 <code>YOUR_NAME</code>和<code>YOUR_EMAIL</code>为自己的内容。</p><pre><code>name: CIon: [push]jobs:  build:    runs-on: ubuntu-latest    steps:    - name: Download Source file      uses: actions/checkout@v2      with:        ref: master # 此处修改为自己存放 Hexo 源文件的分支    - name: Prepare Node env      uses: actions/setup-node@v1      with:        node-version: &quot;10.x&quot;    - name: Set env      env:         GITHUB_ACCESS_TOKEN: $&#123;&#123; secrets.GITHUB_ACCESS_TOKEN &#125;&#125;        run: |        git config --global user.name &#39;YOUR_NAME&#39;        git config --global user.email &#39;YOUR_EMAIL&#39;        sed -i &quot;s/GITHUB_ACCESS_TOKEN/$GITHUB_ACCESS_TOKEN/g&quot; ./_config.yml    - name: Hexo Setup      run: |        npm i -g hexo-cli        npm i hexo-deployer-git --save    - name: Hexo Deploy      run: |        hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h1 id="使用-FTP-进行部署"><a href="#使用-FTP-进行部署" class="headerlink" title="使用 FTP 进行部署"></a>使用 FTP 进行部署</h1><p>Hexo 的 FTP 部署方式会将远程服务器的文件夹清空后，再上传生成的文件。然而，在清空文件夹的步骤中会报错，因而转用 Github Actions 第三方市场中的 Action 进行部署。在<code>blogci.yml</code>文件中添加以下代码，并在<code>Secrets</code>中依次添加 <code>FTP_SERVER</code>、<code>FTP_USERNAME</code>、<code>FTP_PASSWORD</code>。</p><pre><code>    - name: Upload ftp      uses: sebastianpopp/ftp-action@releases/v2      with:        host: $&#123;&#123; secrets.FTP_SERVER &#125;&#125;        user: $&#123;&#123; secrets.FTP_USERNAME &#125;&#125;        password: $&#123;&#123; secrets.FTP_PASSWORD &#125;&#125;        localDir: &quot;public&quot;</code></pre><p>最后将仓库推送至 Github ，就可以看到 GIthub Actions 会自动部署你的博客了。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Mac下通过HEXO在Github上搭建博客</title>
    <link href="/2017/08/using-hexo-building-blog-on-mac/"/>
    <url>/2017/08/using-hexo-building-blog-on-mac/</url>
    
    <content type="html"><![CDATA[<p>经过一番折腾，总算是把Hexo给弄好了。在这期间遇到了各种问题，网上有的教程也有点老了，这里就再写一篇。<strong>最新的教程</strong>可以去<a href="https://hexo.io/zh-cn/docs/index.html">Hexo官网</a>查看。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a><a href="#前期准备" title="前期准备"></a>前期准备</h2><h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a><a href="#安装Xcode" title="安装Xcode"></a>安装Xcode</h3><p>Hexo的编译可能依赖Xcode。这个直接从<a href="http://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;mt=12">App Store</a>上下载就好了，没什么难度。</p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a><a href="#安装node-js" title="安装node.js"></a>安装node.js</h3><p>Hexo是基于node.js的，所以要去<a href="https://nodejs.org/">官网</a>上下载下来安装。版本可以选择稳定版(6.11.2)<del>(4.3.1)</del>也可以选择最新版(8.4.0)<del>(5.7.0)</del>。<br>需要注意的是，Hexo 3.1.1测试的最低版本为0.12，所以安装的版本不要太旧，之前看到网上装的0.8.4的版本，我也这么装，结果有一大堆的报错。</p><p><a id="more"></a></p><h3 id="注册Github账户"><a href="#注册Github账户" class="headerlink" title="注册Github账户"></a><a href="#注册Github账户" title="注册Github账户"></a>注册Github账户</h3><p>在本地搭建好Hexo后可以将内容同步到github上，可以在网上浏览。<br>可以去<a href="https://github.com/">Github官网</a>上去注册，注册的过程我就不罗嗦了，具体的过程可以去<a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool">这个页面</a>上跳到Github的那部分去看。<br>其中配置SSH Keys的那部分，可以选择不配制，不配置的话以后每次提交的时候就需要手动输入账号密码，如果配置了的话就不需要了。</p><h2 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a><a href="#正式安装" title="正式安装"></a>正式安装</h2><p>因为安装包中有些内容在墙外，所以可以换<a href="http://npm.taobao.org/">淘宝源</a>，或者用</p><pre><code>npm install -g hexo-cli --no-optional</code></pre><p>来安装<br>然后进入你要安装的目录，如</p><pre><code>cd ~/Document/hexo</code></pre><p>然后安装</p><pre><code>hexo init</code></pre><p>安装好之后不要忘记执行</p><pre><code>npm install</code></pre><p>至此，就已经安装完毕了。是不是很简单呢？</p><h2 id="后期部署"><a href="#后期部署" class="headerlink" title="后期部署"></a><a href="#后期部署" title="后期部署"></a>后期部署</h2><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a><a href="#添加文章" title="添加文章"></a>添加文章</h3><pre><code>hexo new &quot;postName&quot;</code></pre><p>其中postName是博客名。</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a><a href="#生成静态页面" title="生成静态页面"></a>生成静态页面</h3><pre><code>hexo generate</code></pre><p>或者也可以执行缩写</p><pre><code>hexo g</code></pre><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a><a href="#本地启动" title="本地启动"></a>本地启动</h3><p>执行好上面的命令之后就可以在本地启用服务来看效果了。执行下面的命令：</p><pre><code>hexo sever</code></pre><p>或缩写</p><pre><code>hexo s</code></pre><p>看到 <em>INFO  Hexo is running at <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</em> 之后，就可以在浏览器中打开页面<a href="http://localhost:4000">http://localhost:4000</a>来看了。</p><h3 id="上传至Github"><a href="#上传至Github" class="headerlink" title="上传至Github"></a><a href="#上传至Github" title="上传至Github"></a>上传至Github</h3><h4 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a><a href="#安装git部署插件" title="安装git部署插件"></a>安装git部署插件</h4><p>在部署之前，首先我们要确认在你的Github帐号的Repository中有 <strong>用户名.github.io</strong> 的项目。<br>在确认之后，就可以执行命令</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>来安装插件</p><h4 id="配置-config-yml-文件"><a href="#配置-config-yml-文件" class="headerlink" title="配置 _config.yml 文件"></a><a href="#配置-config-yml-文件" title="配置 _config.yml 文件"></a>配置 _config.yml 文件</h4><p>在Hexo安装的目录，如 <em>~/Document/hexo</em> 中找到 <strong>_config.yml</strong> 文件。打开。<br>翻到最后，找到 <strong>deploy</strong> 字样，改成如下格式：</p><pre><code>deploy:   type: git   repo: https://github.com/用户名/用户名.github.io.git  branch: master</code></pre><p>需要<strong>注意</strong>的是：冒号后面有一个空格；使用github可以不用写branch那一行。<br>如果要使用多个 deployer，可改成如下样式：</p><pre><code>deploy:- type: git  repo:- type: heroku   repo:</code></pre><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a><a href="#同步" title="同步"></a>同步</h4><p>输入命令</p><pre><code>hexo deploy</code></pre><p>或者缩写</p><pre><code>hexo d</code></pre><p>来执行。<br>以后每次执行就可以依次输入下面三行命令：</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre><p>或者其缩写。</p><h2 id="最后优化"><a href="#最后优化" class="headerlink" title="最后优化"></a><a href="#最后优化" title="最后优化"></a>最后优化</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a><a href="#插件" title="插件"></a>插件</h3><p>我使用了几个常见的插件：</p><h4 id="从Wordpress迁移到Hexo"><a href="#从Wordpress迁移到Hexo" class="headerlink" title="从Wordpress迁移到Hexo"></a><a href="#从Wordpress迁移到Hexo" title="从Wordpress迁移到Hexo"></a>从Wordpress迁移到Hexo</h4><pre><code>npm install hexo-migrator-wordpress --save</code></pre><p>在 WordPress 仪表盘中导出数据(“工具(Tools)” → “发布(Export)” → “文章(WordPress)”)<br>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p><pre><code>hexo migrate wordpress &lt;source&gt;</code></pre><h4 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a><a href="#站点地图" title="站点地图"></a>站点地图</h4><pre><code>npm install hexo-generator-sitemap --save</code></pre><p>生成的sitemap.xml可以给搜索引擎收录使用。<br>如果要生成百度的sitemap，使用以下命令：</p><pre><code>npm install hexo-generator-baidu-sitemap --save</code></pre><h4 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a><a href="#RSS订阅" title="RSS订阅"></a>RSS订阅</h4><pre><code>npm install hexo-generator-feed --save</code></pre><p>配置文件里经常看见的<code>/atom.xml</code>就是由这个插件生成的</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a><a href="#主题" title="主题"></a>主题</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes">官方</a>给了很多的主题提供参考，默认的是landscape。<br><del>我使用的是<a href="https://github.com/MOxFIVE/hexo-theme-yelee">yelee</a>，<a href="http://slw.coding.me/">这里</a>可以看看样式。</del><br><del>现在用的是<a href="https://luuman.github.io/2015/12/27/Hexo/HexoTheme/">SPFK Hexo 主题</a>，是基于yilia主题修改的，我觉得挺不错的，就拿来使用了。</del><br>现在使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>，这是一款 Material Design 风格的主题。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="#参考文章" title="参考文章"></a>参考文章</h2><p><a href="https://hexo.io/zh-cn/docs/index.html">Hexo官方文档</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool">hexo你的博客</a><br><a href="http://www.jianshu.com/p/465830080ea9">HEXO+Github,搭建属于自己的博客</a><br><a href="http://www.jianshu.com/p/858ecf233db9">通过Hexo在Github上搭建博客教程</a><br><a href="http://www.jianshu.com/p/739bf1305e66">使用Hexo搭建博客（四），博客的部件和插件</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Google Drive 备份你的数据</title>
    <link href="/2017/04/backup-date-by-google-drive/"/>
    <url>/2017/04/backup-date-by-google-drive/</url>
    
    <content type="html"><![CDATA[<p>有时候你的 VPS 上运行着一些博客等数据，通常我们为了防止数据突然丢失等意外，都会将数据进行备份，下面我就来说说如何使用 Google Drive 来进行数据备份。在本篇文章中，上传到 Google Drive 的都是已经打包过的压缩包，而不是一些源文件，同时你的 VPS 也需要能够连接到 Google 的服务器。</p><h2 id="下载-gdrive"><a href="#下载-gdrive" class="headerlink" title="下载 gdrive"></a><a href="#下载-gdrive" title="下载 gdrive"></a>下载 gdrive</h2><p>在这里我们使用 gdrive 来连接 Google Drive ，并通过它来上传文件。gdrive 是一个比较常用的工具，使用 Go 语言编写，这里是它的 <a href="https://github.com/prasmussen/gdrive">GitHub</a> 地址。</p><h3 id="macOS-安装"><a href="#macOS-安装" class="headerlink" title="macOS 安装"></a><a href="#macOS-安装" title="macOS 安装"></a>macOS 安装</h3><p>macOS 系统可以使用 brew 来安装，如果机器上没有安装 brew 的话也可以使用下面的二进制文件。<br><code>brew install gdrive</code></p><h3 id="二进制文件下载"><a href="#二进制文件下载" class="headerlink" title="二进制文件下载"></a><a href="#二进制文件下载" title="二进制文件下载"></a>二进制文件下载</h3><p>下面列举的是常用的文件，其他系统的文件可前往 <a href="https://dl.slinvent.com/?dir=gdrive">我的镜像网站</a> 或 <a href="https://github.com/prasmussen/gdrive#downloads">GitHub</a> 获取。</p><table><thead><tr><th>文件名</th><th>版本</th><th>适用系统</th><th>Shasum值</th></tr></thead><tbody><tr><td>[gdrive-osx-x64](https://dl.slinvent.com/gdrive/gdrive-osx-x64)</td><td>2.1.0</td><td>OS X 64-bit</td><td>297ccf3c945b364b5d306cef335ba44b0900e927</td></tr><tr><td>[gdrive-linux-x64](https://dl.slinvent.com/gdrive/gdrive-linux-x64)</td><td>2.1.0</td><td>Linux 64-bit</td><td>4fd8391b300cac45963e53da44dcfe68da08d843</td></tr><tr><td>[gdrive-windows-386.exe](https://dl.slinvent.com/gdrive/gdrive-windows-386.exe)</td><td>2.1.0</td><td>Window 32-bit</td><td>1429200631b598543eddc3df3487117cad95adbb</td></tr><tr><td>[gdrive-windows-x64.exe](https://dl.slinvent.com/gdrive/gdrive-windows-x64.exe)</td><td>2.1.0</td><td>Windows 64-bit</td><td>17f692a027a049385af2576503cd376593cc87b7</td></tr></tbody></table><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a><a href="#源码安装" title="源码安装"></a>源码安装</h3><p>这里就不过多介绍了，一般不怎么使用，就只放个代码，详细的可前往 <a href="https://github.com/prasmussen/gdrive#compile-from-source">GitHub</a> 查看。<br><code>go get github.com/prasmussen/gdrive</code></p><h2 id="使用-gdrive"><a href="#使用-gdrive" class="headerlink" title="使用 gdrive"></a><a href="#使用-gdrive" title="使用 gdrive"></a>使用 gdrive</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="#下载" title="下载"></a>下载</h3><p>这里以 Linux 64bit 为例，首先是下载 gdrive</p><pre><code>wget -O gdrive https://dl.slinvent.com/gdrive/gdrive-linux-x64chmod +x gdrivemv gdrive /usr/bin</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a><a href="#登录" title="登录"></a>登录</h3><p>然后运行<code>gdrive about</code>进行登录，我们可以看到如下的提示，将网址复制到浏览器中，Google 授权之后我们会得到授权码，再将授权码粘贴到 ssh 中。<br><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-22%20%E4%B8%8B%E5%8D%8811.27.58.png" alt="gdrive about 运行界面"></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><a href="#同步" title="同步"></a>同步</h3><p>之后我们可以在 Google Drive 中创建一个文件夹，然后在终端里运行：<br><code>gdrive list</code>来查看文件夹所代表的id，接下来我们就可以运行同步命令了。<br><code>gdrive sync upload &lt;文件夹所在位置&gt; &lt;文件夹id&gt;</code><br>如：<code>gdrive sync upload /home/backup 0Bx90C1SIFScgcGozNXphQ2FxTXX</code></p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a><a href="#帮助" title="帮助"></a>帮助</h3><p>我们主要会使用到的命令就这几个，当然 gdrive 还有更多地命令可供使用，可以运行<code>gdrive help</code>获取更多命令的使用帮助。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#参考资料" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/prasmussen/gdrive">https://github.com/prasmussen/gdrive</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>backup</tag>
      
      <tag>Google Drive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半加器与全加器</title>
    <link href="/2016/11/half-adder-and-full-adder/"/>
    <url>/2016/11/half-adder-and-full-adder/</url>
    
    <content type="html"><![CDATA[<p><strong>半加器：</strong></p><p>半加器电路是指对两个输入数据位相加，输出一个结果位和进位，没有进位输入的加法器电路。 是实现两个一位二进制数的加法运算电路。</p><p>逻辑图：</p><p><img src="/images/wpid-5a89d3c6d51e3e14a911761ca6130dd0_53110121.png" alt="wpid-5a89d3c6d51e3e14a911761ca6130dd0_53110121"></p><p><a id="more"></a></p><p>真值表：</p><p><img src="/images/wpid-5a89d3c6d51e3e14a911761ca6130dd0_59b9c230-6990-4fb0-8105-69ecbdf23d0c1.png" alt="wpid-5a89d3c6d51e3e14a911761ca6130dd0_59b9c230-6990-4fb0-8105-69ecbdf23d0"></p><p> <strong>全加器：</strong></p><p>全加器英语名称为full-adder，是用门电路实现两个二进制数相加并求出和的组合线路，称为一位全加器。一位全加器可以处理低位进位，并输出本位加法进位。多个一位全加器进行级联可以得到多位全加器。</p><p>逻辑图：</p><p><img src="/images/wpid-5a89d3c6d51e3e14a911761ca6130dd0_131598811.png" alt="wpid-5a89d3c6d51e3e14a911761ca6130dd0_131598811"></p><p>真值表：</p><p><img src="/images/wpid-5a89d3c6d51e3e14a911761ca6130dd0_b2ca6d99-5066-4638-a403-1223886910de1.png" alt="wpid-5a89d3c6d51e3e14a911761ca6130dd0_b2ca6d99-5066-4638-a403-1223886910de1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界，你好！</title>
    <link href="/2016/08/hello-world/"/>
    <url>/2016/08/hello-world/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>用 WordPress 搭好了博客，之前的数据库被我搞坏了，又没有备份，所以就新开了一个。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 输出时保留的小数位数</title>
    <link href="/2016/08/c-decimal-precision/"/>
    <url>/2016/08/c-decimal-precision/</url>
    
    <content type="html"><![CDATA[<p>cout语句中有一个专门用来控制小数位数的函数(setprecison)，可以方便地输出不同的小数位数。</p><p>这个函数需要包含头文件<code>#include &lt;iomanip&gt;</code></p><p>我们来看看用法：</p><blockquote><p>cout &lt;&lt; setprecision(输出位数) &lt;&lt; 变量/数字 &lt;&lt; endl;</p></blockquote><p>例如：</p><p><code>cout &lt;&lt; setprecision(2) &lt;&lt; 3.123 &lt;&lt; endl;</code></p><p>我们得到的结果就是「3.12」。</p><p>但需要注意下一个例子：</p><p><code>cout &lt;&lt; setprecision(4) &lt;&lt; 3.123456 &lt;&lt; endl;</code></p><p>这时输出的结果就是<strong>「3.1235」</strong>。</p><p>因为setprecision函数取到最后一位时，会自动<strong>四舍五入</strong>。（类似于C中printf的%.5f，也会四舍五入）</p><p>那如何不要四舍五入呢？很简单就是加上fixed：</p><blockquote><p>cout &lt;&lt; fixed &lt;&lt; setprecision(输出位数) &lt;&lt; 变量/数字 &lt;&lt; endl;</p></blockquote><p>我们来看刚刚那个例子：</p><p><code>cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; 3.123456 &lt;&lt; endl;</code></p><p>这时输出的结果就是我们想要的「3.1234」了。</p><hr><p>参考文章：</p><p><a href="http://www.cnblogs.com/krisdy/archive/2009/04/17/1438402.html">关于保留小数点后几位数字之我见</a></p><p><a href="http://it-easy.tw/cout-float/">cout控制輸出的小數點位數</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android入门</title>
    <link href="/2016/08/getting-started-with-android/"/>
    <url>/2016/08/getting-started-with-android/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>之前报名了Google举办的Study Jams，现在已经成功结业了，也勉强算是入门了Android。</p><h2 id="VIEW"><a href="#VIEW" class="headerlink" title="VIEW"></a><a href="#VIEW" title="VIEW"></a>VIEW</h2><h3 id="XML，可拓展标记语言。"><a href="#XML，可拓展标记语言。" class="headerlink" title="XML，可拓展标记语言。"></a><a href="#XML，可拓展标记语言。" title="XML，可拓展标记语言。"></a>XML，可拓展标记语言。</h3><p>在Android中，使用XML来确定不同的VIEWS。<br>XML中由一个个不同的标签构成，需要注意每个标签结束之后都要关闭标签。如：<code>/&gt;</code>或<code>&lt;/LinearLayout&gt;</code><br>标签中有各种不同的属性。属性可以决定手机上View的行为或外观的特性。</p><h3 id="View的分类"><a href="#View的分类" class="headerlink" title="View的分类"></a><a href="#View的分类" title="View的分类"></a>View的分类</h3><p>常见的VIEW：</p><ol><li>TextView</li><li>ImageView</li><li>Button</li><li>ScrollView</li></ol><h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a><a href="#dp" title="dp"></a>dp</h3><p>dp (density-independent pixles) 密度无关像素</p><h3 id="wrap-content"><a href="#wrap-content" class="headerlink" title="wrap_content"></a><a href="#wrap-content" title="wrap_content"></a>wrap_content</h3><p>自适应宽度或高度</p><h3 id="设置字体大小"><a href="#设置字体大小" class="headerlink" title="设置字体大小"></a><a href="#设置字体大小" title="设置字体大小"></a>设置字体大小</h3><p>android:textSize=”45sp”<br>android:textAppearance=”?android:textAppearanceLarge”</p><h3 id="设置字体颜色"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a><a href="#设置字体颜色" title="设置字体颜色"></a>设置字体颜色</h3><p>android:textColor=”@andorid:color/darker_gray”<br>android:textColor=”#十六进制数”<br>具体配色可在<a href="https://www.google.com/design/spec/material-design/introduction.html">Materal Design</a>上查看</p><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a><a href="#ImageView" title="ImageView"></a>ImageView</h3><p>@drawable/cake<br><strong>只引用有效文件</strong><br>@:引用<br>drawable:引用类型<br>cake:文件名（不需要后缀）</p><h3 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a><a href="#ViewGroup" title="ViewGroup"></a>ViewGroup</h3><ul><li>拥有宽度、高度、背景色等属性</li><li>ViewGroup里面包含的是其它View</li><li><p>ViewGroup也算一个View</p><h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a><a href="#LinearLayout" title="LinearLayout"></a>LinearLayout</h3></li><li><p>把子视图排成竖直或水平的一排*   可以在其中摆放任意数量的View<br><img src="/images/572b11a394d88.png" alt="572b11a394d88"></p></li></ul><h4 id="match-parent"><a href="#match-parent" class="headerlink" title="match_parent"></a><a href="#match-parent" title="match_parent"></a>match_parent</h4><p>将当前View设置成与父视图等宽或等高<br><img src="/images/572b11a2033d1.png" alt="屏幕快照 2016-05-03 下午9.01.41"></p><h4 id="子视图空间平分"><a href="#子视图空间平分" class="headerlink" title="子视图空间平分"></a><a href="#子视图空间平分" title="子视图空间平分"></a>子视图空间平分</h4><pre><code>android:layout_height=&quot;0dp&quot;android:layout_weight=&quot;1&quot;</code></pre><h4 id="View边框"><a href="#View边框" class="headerlink" title="View边框"></a><a href="#View边框" title="View边框"></a>View边框</h4><h5 id="padding"><a href="#padding" class="headerlink" title="padding"></a><a href="#padding" title="padding"></a>padding</h5><p>包含边框<br><img src="/images/572b119ec0a28.png" alt="屏幕快照 2016-05-03 下午9.01.45"></p><ul><li>andorid:padding = “8dp”<br>OR</li><li>andorid:paddingLeft = “8dp”</li><li>andorid:paddingRight = “8dp”</li><li>andorid:paddingTop = “8dp”</li><li><p>andorid:paddingBottom = “8dp”</p><h5 id="margin"><a href="#margin" class="headerlink" title="margin"></a><a href="#margin" title="margin"></a>margin</h5><p>不包含边框<br><img src="/images/572b119edf4de.png" alt="屏幕快照 2016-05-03 下午9.01.50"></p></li><li><p>andorid:layout_margin = “8dp”<br>OR</p></li><li>andorid:layout_marginLeft = “8dp”</li><li>andorid:layout_marginRight = “8dp”</li><li>andorid:layout_marginTop = “8dp”</li><li>andorid:layout_marginBottom = “8dp”<br>LinearLayout例子:<pre><code>&lt;LinearLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;ImageView    android:src=&quot;@drawable/ocean&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;0dp&quot;    android:layout_weight=&quot;1&quot;    android:scaleType=&quot;centerCrop&quot; /&gt;&lt;TextView    android:text=&quot;You&#39;re invited!&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:textColor=&quot;@android:color/white&quot;    android:textSize=&quot;54sp&quot;    android:background=&quot;#009688&quot; /&gt;&lt;TextView    android:text=&quot;Bonfire at the beach&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:textColor=&quot;@android:color/white&quot;    android:textSize=&quot;34sp&quot;    android:background=&quot;#009688&quot; /&gt;&lt;/LinearLayout&gt;</code></pre></li></ul><p><img src="/images/572b11a95bee5.png" alt="屏幕快照 2016-05-03 下午9.02.00"></p><h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a><a href="#RelativeLayout" title="RelativeLayout"></a>RelativeLayout</h3><ul><li><p>可以将子视图与父布局或子视图之间相对排列</p><h4 id="View在父视图中摆放位置"><a href="#View在父视图中摆放位置" class="headerlink" title="View在父视图中摆放位置"></a><a href="#View在父视图中摆放位置" title="View在父视图中摆放位置"></a>View在父视图中摆放位置</h4></li><li><p>android:layout_alignParentTop = “true” or “false”</p></li><li>android:layout_alignParentBottom = “true” or “false”</li><li>android:layout_alignParentLeft = “true” or “false”</li><li>android:layout_alignParentRight = “true” or “false”</li><li>android:layout_centerHorizontal = “true” or “false”</li><li><p>android:layout_centerVertical = “true” or “false”</p><h4 id="View之间的相对摆放位置"><a href="#View之间的相对摆放位置" class="headerlink" title="View之间的相对摆放位置"></a><a href="#View之间的相对摆放位置" title="View之间的相对摆放位置"></a>View之间的相对摆放位置</h4></li><li><p>android:id = “@id+/id_name”</p></li><li>android:layout_toLeftOf = “@id/id_name”</li><li>android:layout_above = “@id/id_name”</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 0 开始在 VPS 上部署 Laravel (Ubuntu 14.04)</title>
    <link href="/2016/08/deploy-lavaral-on-ubuntu/"/>
    <url>/2016/08/deploy-lavaral-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><a href="#准备工作" title="准备工作"></a>准备工作</h2><p>首先，你需要有一个 VPS，我这里以 Ubuntu 14.04 为例，来说说怎么部署一个最简单的 Laravel 应用。我这里都是以 root 权限运行，如果不是 root 用户，请在命令前加上<code>sudo</code>。</p><h3 id="安装语言包并设置默认语言"><a href="#安装语言包并设置默认语言" class="headerlink" title="安装语言包并设置默认语言"></a><a href="#安装语言包并设置默认语言" title="安装语言包并设置默认语言"></a>安装语言包并设置默认语言</h3><p>这样设置了之后可以防止之后因为编码错误而造成的一系列问题<br><code>apt-get update</code><br><code>apt-get install -y language-pack-en-base unzip</code><br><code>locale-gen en_US.UTF-8</code></p><h3 id="安装-PHP7-的准备工作"><a href="#安装-PHP7-的准备工作" class="headerlink" title="安装 PHP7 的准备工作"></a><a href="#安装-PHP7-的准备工作" title="安装 PHP7 的准备工作"></a>安装 PHP7 的准备工作</h3><p><code>apt-get install -y software-properties-common</code><br><code>LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</code><br><code>apt-get update</code></p><p><a id="more"></a></p><h3 id="安装-PHP7-amp-nginx-amp-MySQL5-6"><a href="#安装-PHP7-amp-nginx-amp-MySQL5-6" class="headerlink" title="安装 PHP7 &amp; nginx &amp; MySQL5.6"></a><a href="#安装-PHP7-amp-nginx-amp-MySQL5-6" title="安装 PHP7 &amp; nginx &amp; MySQL5.6"></a>安装 PHP7 &amp; nginx &amp; MySQL5.6</h3><p><code>apt-get install -y php7.1 php7.1-mysql php7.1-fpm php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring nginx mysql-server-5.6</code><br>安装 MySQL 的时候要输入 root 密码，记住这个密码<br><img src="/images/mysql-password.png" alt="mysql-password"></p><p>安装完后打开浏览器，输入 VPS 的 IP 地址，看到如下网页，则说明安装成功。<br><img src="/images/nginx-setup.png" alt="nginx-setup"></p><h2 id="配置-PHP-和-nginx"><a href="#配置-PHP-和-nginx" class="headerlink" title="配置 PHP 和 nginx"></a><a href="#配置-PHP-和-nginx" title="配置 PHP 和 nginx"></a>配置 PHP 和 nginx</h2><h3 id="配置-PHP"><a href="#配置-PHP" class="headerlink" title="配置 PHP"></a><a href="#配置-PHP" title="配置 PHP"></a>配置 PHP</h3><p><code>vi /etc/php/7.1/fpm/php.ini</code><br>将<code>;cgi.fix_pathinfo=1</code>改成<code>cgi.fix_pathinfo=0</code><br><code>vi /etc/php/7.1/fpm/pool.d/www.conf</code><br>配置<code>listen = /var/run/php7.1-fpm.sock</code><br>之后重启 php-fpm <code>service php7.1-fpm restart</code></p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a><a href="#配置-nginx" title="配置 nginx"></a>配置 nginx</h3><p><code>vi /etc/nginx/sites-available/default</code><br>参考如下修改 nginx 的配置</p><pre><code>listen 80 default_server;listen [::]:80 default_server;root /var/www/laravel/public;index index.php index.html index.htm;# Make site accessible from http://localhost/server_name localhost;location / &#123;        try_files $uri $uri/ /index.php?$query_string;&#125;location ~ \.php$ &#123;        try_files $uri /index.php =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php7.1-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;&#125;</code></pre><h2 id="部署-Laravel"><a href="#部署-Laravel" class="headerlink" title="部署 Laravel"></a><a href="#部署-Laravel" title="部署 Laravel"></a>部署 Laravel</h2><h3 id="安装-composer"><a href="#安装-composer" class="headerlink" title="安装 composer"></a><a href="#安装-composer" title="安装 composer"></a>安装 composer</h3><pre><code>php -r &quot;copy(&#39;https://getcomposer.org/installer&#39;, &#39;composer-setup.php&#39;);&quot;php -r &quot;if (hash_file(&#39;SHA384&#39;, &#39;composer-setup.php&#39;) === &#39;e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae&#39;) &#123; echo &#39;Installer verified&#39;; &#125; else &#123; echo &#39;Installer corrupt&#39;; unlink(&#39;composer-setup.php&#39;); &#125; echo PHP_EOL;&quot;php composer-setup.phpphp -r &quot;unlink(&#39;composer-setup.php&#39;);&quot;mv composer.phar /usr/local/bin/composer</code></pre><h2 id="配置-Laravel"><a href="#配置-Laravel" class="headerlink" title="配置 Laravel"></a><a href="#配置-Laravel" title="配置 Laravel"></a>配置 Laravel</h2><p>把文件<a href="/images/laravel.zip">larave</a>上传至<code>/var/www/</code>目录下<br>修改<code>storage</code>文件夹权限<code>chmod -R 775 /var/www/storage/</code><br>修改 <code>www</code> 文件夹权限 <code>chown www-data:www-data -R /var/www/</code><br>编辑<code>env</code>将<code>DB_PASSWORD=root</code>中的<code>root</code>改为之前设置的密码<br>之后运行命令<code>mv env .env</code><br>运行<code>composer install</code>，在国内的话，安装时间会比较长</p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a><a href="#安装完成" title="安装完成"></a>安装完成</h2><p>现在打开浏览器访问 VPS 的 IP 地址来看看效果吧。<br><img src="/images/laravel.png" alt="larave"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a href="#参考文档" title="参考文档"></a>参考文档</h2><p><a href="https://laravist.com/discuss/752">从零开始部署 Laravel 项目</a><br><a href="https://getcomposer.org/download/">Download Composer</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Laravel</tag>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyper_ 主机性能</title>
    <link href="/2016/08/hyper-performance-test/"/>
    <url>/2016/08/hyper-performance-test/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Hyper<em> 刚刚正式发布，Hyper</em>是世界上第一家 Container-native 的 Docker 云服务。它的核心是底层的<a href="http://hypercontainer.io">HyperContainer</a>虚拟化容器技术，以及<a href="http://hypernetes.com">Hypernetes</a>多租户的 Kubernetes 系统。抱着一颗好奇心就测试了一下性能,发现性能还是不错的。</p><pre><code>----------------------------------------------------------------------CPU model            : Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20GHzNumber of cores      : 1CPU frequency        : 2199.998 MHzTotal amount of ram  : 494 MBTotal amount of swap : 0 MBSystem uptime        : 0days, 0:2:52Load average         : 0.32, 0.14, 0.05OS                   : CentOS 7.2.1511Arch                 : x86_64 (64 Bit)Kernel               : 4.4.12-hyper----------------------------------------------------------------------Node Name            IPv4 address        Download SpeedCacheFly            205.234.175.175        80.0MB/sLinode, Tokyo, JP        106.187.96.148        13.5MB/sLinode, Singapore, SG        139.162.23.4        4.31MB/sLinode, London, UK        176.58.107.39        4.73MB/sLinode, Frankfurt, DE        139.162.130.8        4.11MB/sLinode, Fremont, CA        50.116.14.9        24.4MB/sSoftlayer, Dallas, TX        173.192.68.18        36.7MB/sSoftlayer, Seattle, WA        67.228.112.250        47.8MB/sSoftlayer, Frankfurt, DE    159.122.69.4        5.54MB/sSoftlayer, Singapore, SG    119.81.28.170        6.97MB/sSoftlayer, HongKong, CN        119.81.130.170        8.23MB/s----------------------------------------------------------------------I/O speed(1st run) : 429 MB/sI/O speed(2nd run) : 321 MB/sI/O speed(3rd run) : 283 MB/sAverage I/O speed  : 344.333 MB/s</code></pre><p>下面的是 DaoCloud 的性能测试，摘自<a href="https://yux.io/2016/05/13/daocloud-benchmark/">DaoCloud主机性能初探</a></p><pre><code>----------------------------------------------------------------------CPU model            : Common KVM CPUNumber of cores      : 4CPU frequency        : 2593.748 MHzTotal amount of ram  : 12017 MBTotal amount of swap : 4607 MBSystem uptime        : 1days, 0:28:27OS                   : Debian GNU/Linux 8Arch                 : x86_64 (64 Bit)Kernel               : 3.13.0-85-generic----------------------------------------------------------------------Node Name                       IPv4 address            Download Speedping: unknown hostCacheFlyLinode, Tokyo, JP               106.187.96.148          5.73MB/sLinode, Singapore, SG           139.162.23.4            5.67MB/sLinode, London, UK              176.58.107.39           4.41MB/sLinode, Frankfurt, DE           139.162.130.8           5.16MB/sLinode, Fremont, CA             50.116.14.9             5.52MB/sSoftlayer, Dallas, TX           173.192.68.18           5.28MB/sSoftlayer, Seattle, WA          67.228.112.250          5.33MB/sSoftlayer, Frankfurt, DE        159.122.69.4            5.26MB/sSoftlayer, Singapore, SG        119.81.28.170           5.03MB/sSoftlayer, HongKong, CN         119.81.130.170          4.88MB/s----------------------------------------------------------------------I/O speed(1st run) : 94.0 MB/sI/O speed(2nd run) : 68.8 MB/sI/O speed(3rd run) : 62.2 MB/sAverage I/O: 75 MB/s</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>hyper docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 0 开始在 VPS 上部署 Laravel (CentOS 7.2)</title>
    <link href="/2016/08/deploy-lavaral-on-centos/"/>
    <url>/2016/08/deploy-lavaral-on-centos/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><a href="#准备工作" title="准备工作"></a>准备工作</h2><p>之前写了一个 Ubuntu 系统的搭建教程，这次以 CentOS 7.2 为例，来说说怎么部署一个最简单的 Laravel 应用。我这里都是以 root 权限运行，如果不是 root 用户，请在命令前加上<code>sudo</code>。<br>先运行<code>yum update -y</code></p><h2 id="安装-lnmp-一键安装包"><a href="#安装-lnmp-一键安装包" class="headerlink" title="安装 lnmp 一键安装包"></a><a href="#安装-lnmp-一键安装包" title="安装 lnmp 一键安装包"></a>安装 lnmp 一键安装包</h2><p>前期使用一键安装包可以有效防止莫名其妙出现的错误，简化安装步骤，这个安装过程预计需要1个小时左右的安装时间。<br>注意事项：<br>需要<strong>3GB</strong>以上硬盘剩余空间<br>需要<strong>128MB以上</strong>内存(如果为128MB的小内存VPS,Xen的需要有SWAP,OpenVZ的至少要有128MB以上的vSWAP或突发内存)，注意小内存请勿使用64位系统！<br>安装MySQL 5.6或5.7及MariaDB 10必须<strong>1G以上内存</strong>!</p><p><a id="more"></a></p><p>首先安装 screen：<code>yum install -y screen</code><br>然后运行<code>screen -S lnmp</code><br>如果网路出现中断，可以执行命令 <code>screen -r lnmp</code> 重新连接安装窗口<br>然后是安装 lnmp:<code>wget -c http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;amp;&amp;amp; tar zxf lnmp1.3-full.tar.gz &amp;amp;&amp;amp; cd lnmp1.3-full &amp;amp;&amp;amp; ./install.sh lnmp</code><br>安装过程中需要输入 MySQL 的 root 密码，后面设置可以自己设置，或者参考我下面的设置。</p><pre><code>+------------------------------------------------------------------------+|          LNMP V1.3 for CentOS Linux Server, Written by Licess          |+------------------------------------------------------------------------+|        A tool to auto-compile &amp; install LNMP/LNMPA/LAMP on Linux       |+------------------------------------------------------------------------+|          For more information please visit http://www.lnmp.org         |+------------------------------------------------------------------------+Please setup root password of MySQL.(Default password: root)Please enter: rootMySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: YYou will disable the InnoDB Storage Engine!===========================You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.48 (Default)3: Install MySQL 5.6.294: Install MariaDB 5.5.485: Install MariaDB 10.0.236: Install MySQL 5.7.11Enter your choice (1, 2, 3, 4, 5 or 6): 2You will install MySQL 5.5.48===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.45 (Default)4: Install PHP 5.5.365: Install PHP 5.6.226: Install PHP 7.0.7Enter your choice (1, 2, 3, 4, 5 or 6): 6You will install PHP 7.0.7===========================You have 3 options for your Memory Allocator install.1: Don&#39;t install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMallocEnter your choice (1, 2 or 3): 1You will install not install Memory Allocator.Press any key to install...or Press Ctrl+c to cancel</code></pre><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a><a href="#配置-nginx" title="配置 nginx"></a>配置 nginx</h3><p><code>vi /usr/local/nginx/conf/nginx.conf</code><br>参考如下修改 nginx 的配置</p><pre><code>listen 80 default_server;listen [::]:80 default_server;root /var/www/laravel/public;index index.php index.html index.htm;# Make site accessible from http://localhost/server_name localhost;location / &#123;        try_files $uri $uri/ /index.php?$query_string;&#125;location ~ \.php$ &#123;        try_files $uri /index.php =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;&#125;</code></pre><h2 id="部署-Laravel"><a href="#部署-Laravel" class="headerlink" title="部署 Laravel"></a><a href="#部署-Laravel" title="部署 Laravel"></a>部署 Laravel</h2><h3 id="安装-composer"><a href="#安装-composer" class="headerlink" title="安装 composer"></a><a href="#安装-composer" title="安装 composer"></a>安装 composer</h3><pre><code>php -r &quot;copy(&#39;https://getcomposer.org/installer&#39;, &#39;composer-setup.php&#39;);&quot;php -r &quot;if (hash_file(&#39;SHA384&#39;, &#39;composer-setup.php&#39;) === &#39;e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae&#39;) &#123; echo &#39;Installer verified&#39;; &#125; else &#123; echo &#39;Installer corrupt&#39;; unlink(&#39;composer-setup.php&#39;); &#125; echo PHP_EOL;&quot;php composer-setup.phpphp -r &quot;unlink(&#39;composer-setup.php&#39;);&quot;mv composer.phar /usr/local/bin/composer</code></pre><h2 id="配置-Laravel"><a href="#配置-Laravel" class="headerlink" title="配置 Laravel"></a><a href="#配置-Laravel" title="配置 Laravel"></a>配置 Laravel</h2><p>把文件<a href="/images/laravel.zip">larave</a>上传至<code>/home/wwwroot/</code>目录下<br>修改<code>storage</code>文件夹权限<code>chmod -R 775 /home/wwwroot/laravel/storage/</code><br><code>chown www:www -R /home/wwwroot/laravel/</code><br>编辑<code>env</code>将<code>DB_PASSWORD=root</code>中的<code>root</code>改为之前设置的密码<br>之后运行命令<code>mv env .env</code><br>运行<code>composer install</code>，在国内的话，安装时间会比较长</p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a><a href="#安装完成" title="安装完成"></a>安装完成</h2><p>现在打开浏览器访问 VPS 的 IP 地址来看看效果吧。<br><img src="/images/laravel.png" alt="larave"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a href="#参考文档" title="参考文档"></a>参考文档</h2><p><a href="https://webtatic.com/packages/php70/">PHP 7 on CentOS/RHEL 6.8 and 7.2 via Yum</a><br><a href="http://www.ahlinux.com/centos/23340.html">阿里云CentOS 7.1使用yum安装MySql5.6.24</a><br><a href="https://laravist.com/discuss/752">从零开始部署 Laravel 项目</a><br><a href="https://getcomposer.org/download/">Download Composer</a><br><a href="https://www.slinvent.com/2016/deploy-laravel-on-vps/">从 0 开始在 VPS 上部署 Laravel (Ubuntu 14.04)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Laravel</tag>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 Let’s Encrypt 使你的网站用上 https</title>
    <link href="/2016/08/lets-encrypt-https/"/>
    <url>/2016/08/lets-encrypt-https/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="/images/006tNbRwgw1f5tq6hq9rnj309a02774g.jpg" alt="006tNbRwgw1f5tq6hq9rnj309a02774g">￼</p><p>在网上查找了不少资料之后终于弄好了 Let’s Encrypt 的 https 证书。</p><h2 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a><a href="#Let’s-Encrypt" title="Let’s Encrypt"></a>Let’s Encrypt</h2><p><a href="https://letsencrypt.org/">Let’s Encrypt</a>是由EFF、Mozilla、Cisco、Akamai、IdenTrust与密西根大学研究人员共同创立的免费的凭证中心，目的在于推动全球所有的网站都使用HTTPS加密传输，并由非营利的网际网路安全研究组织Internet Security Research Group(ISRG)负责营运。<br>我选择 Let’s Encrypt 的原因之一就是因为证书是免费的。</p><p><a id="more"></a></p><h2 id="首次生成证书"><a href="#首次生成证书" class="headerlink" title="首次生成证书"></a><a href="#首次生成证书" title="首次生成证书"></a>首次生成证书</h2><h3 id="从Github签出Let’s-Encrypt的源代码"><a href="#从Github签出Let’s-Encrypt的源代码" class="headerlink" title="从Github签出Let’s Encrypt的源代码"></a><a href="#从Github签出Let’s-Encrypt的源代码" title="从Github签出Let’s Encrypt的源代码"></a>从Github签出Let’s Encrypt的源代码</h3><p><code>git clone https://github.com/letsencrypt/letsencrypt</code></p><h3 id="进入本地源代码目录"><a href="#进入本地源代码目录" class="headerlink" title="进入本地源代码目录"></a><a href="#进入本地源代码目录" title="进入本地源代码目录"></a>进入本地源代码目录</h3><p><code>cd letsencrypt</code><br>Let’s Encrypt提供多种认证方式，因为之前在VPS上有了HTTP的网站，所以这里采用了webroot的方式，其他方式请参考官方文档</p><h4 id="主域名的认证"><a href="#主域名的认证" class="headerlink" title="主域名的认证"></a><a href="#主域名的认证" title="主域名的认证"></a>主域名的认证</h4><p><code>./letsencrypt-auto --debug certonly --webroot --email name@your_main_domain.com -d your_main_domain.com -d www.your_main_domain.com -w /var/www/your_main_domain.com</code></p><h4 id="子域名的认证"><a href="#子域名的认证" class="headerlink" title="子域名的认证"></a><a href="#子域名的认证" title="子域名的认证"></a>子域名的认证</h4><p><code>./letsencrypt-auto --debug certonly --webroot --email name@your_main_domain.com -d subdomain.your_main_domain.com -w /var/www/your_main_domain.com/subdomain</code><br>然后在弹出的蓝底白字提示框中一路点击”OK”</p><h3 id="注意如下问题"><a href="#注意如下问题" class="headerlink" title="注意如下问题"></a><a href="#注意如下问题" title="注意如下问题"></a>注意如下问题</h3><pre><code>*   请将命令中的name, your_main_domain.com, subdomain替换成你自己的名字，域名以及子域名 *   因为Gentoo目前是在试验阶段，所以命令行加上--debug参数*   参数--email如果没有在命令行加上，会在随后弹出的对话框里提示你填写*   -w指定Web服务器网址内容放置的目录，请指定自己放置的目录</code></pre><p>生成的证书放在<code>/etc/letsencrypt/live/[网站域名]</code>下</p><table><thead><tr><th>文件名</th><th>内容</th></tr></thead><tbody><tr><td>cert.pem</td><td>服务端证书</td></tr><tr><td>chain.pem</td><td>浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</td></tr><tr><td>fullchain.pem</td><td>包括了cert.pem和chain.pem的内容</td></tr><tr><td>privkey.pem</td><td>证书的私钥</td></tr></tbody></table><p>一般情况下 <code>fullchain.pem</code> 和 <code>privkey.pem</code> 就够用了</p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a><a href="#Nginx配置" title="Nginx配置"></a>Nginx配置</h2><p>我使用的是 lnmp 的一键安装包，打开 <code>/usr/local/nginx/conf/vhost/</code> 下 <code>域名.conf</code> 的文件，改成类似下面的设置。</p><pre><code>server &#123;    listen    80;    server_name    www.slinvent.com slinvent.com;    return   301 https://$server_name$request_uri;&#125;server    &#123;        listen 443 ssl;        #listen [::]:80;        server_name www.slinvent.com slinvent.com;        index index.html index.htm index.php default.html default.htm default.php;        root  /home/wwwroot/www.slinvent.com;        ssl_certificate /etc/letsencrypt/live/slinvent.com/fullchain.pem;        ssl_certificate_key /etc/letsencrypt/live/slinvent.com/privkey.pem;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        ssl_ciphers AES256+EECDH:AES256+EDH:!aNULL;        ……    &#125;</code></pre><p>其中<code>return   301 https://$server_name$request_uri;</code>是用来实现80端口到443端口的流量跳转的。<br>最后再执行：<code>/etc/init.d/nginx reload</code> 重新载入配置使其生效。</p><h2 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a><a href="#更新证书" title="更新证书"></a>更新证书</h2><p><code>./letsencrypt-auto renew</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="#参考文章" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/5575893df1ed">使用Let’s Encrypt轻松实现站点https</a><br><a href="http://www.jianshu.com/p/ba2a384e89ec">Let’s Encrypt给你的网站穿上HTTPS的铠甲，防止http劫持</a><br><a href="http://bbs.qcloud.com/thread-12059-1-1.html">如何在Nginx上部署 Let’s Encrypt 证书</a><br><a href="http://www.vpser.net/build/letsencrypt-free-ssl.html">免费SSL安全证书Let’s Encrypt安装使用教程(附Nginx/Apache配置)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>letsencrypt</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mingw32 gcc/g++ 在windows 8下的安装过程</title>
    <link href="/2016/08/mingw32-gcc-g-install-on-windows-8/"/>
    <url>/2016/08/mingw32-gcc-g-install-on-windows-8/</url>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a><a href="#下载地址" title="下载地址"></a>下载地址</h4><p><a href="http://sourceforge.net/projects/mingw/files/Installer/mingw-get/mingw-get-0.6.2-beta-20131004-1/mingw-get-0.6.2-mingw32-beta-20131004-1-bin.zip/download">mingw-get-0.6.2-mingw32-beta-20131004-1-bin.zip</a></p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a><a href="#解压" title="解压"></a>解压</h4><p>将其解压至 C:\mingw</p><p><a id="more"></a></p><h4 id="Win-R-打开运行-gt-输入cmd-gt-点击确定"><a href="#Win-R-打开运行-gt-输入cmd-gt-点击确定" class="headerlink" title="Win+R 打开运行 -&gt; 输入cmd -&gt; 点击确定"></a><a href="#Win-R-打开运行-gt-输入cmd-gt-点击确定" title="Win+R 打开运行 -&gt; 输入cmd -&gt; 点击确定"></a>Win+R 打开运行 -&gt; 输入cmd -&gt; 点击确定</h4><p><img src="/images/1.jpg" alt="1"></p><p>输入 cd c:\mingw\bin</p><p><img src="/images/2.jpg" alt="2"></p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a><a href="#更新" title="更新"></a>更新</h4><p>输入 mingw-get upgrade</p><p><img src="/images/3.jpg" alt="3"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="#安装" title="安装"></a>安装</h4><p><img src="/images/4.jpg" alt="4"></p><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a><a href="#环境设置" title="环境设置"></a>环境设置</h4><p>“计算机”右键-&gt;“属性”</p><p><img src="/images/5.jpg" alt="5"></p><p><img src="/images/6.jpg" alt="6"></p><p><img src="/images/7.jpg" alt="7"></p><p>“高级系统设置” -&gt; “环境变量” ，在”系统变量（S）”，在“Path”，里增加 gcc/g++的目录：</p><p>c:\mingw\bin</p><p>新建LIBRARY_PATH变量，如果有的话，在值中加入C:\MinGW\lib;</p><p>新建</p><p>C_INCLUDEDE_PATH变量，值设为C:\MinGW\include;</p><h4 id="重新启动计算机命令行"><a href="#重新启动计算机命令行" class="headerlink" title="重新启动计算机命令行"></a><a href="#重新启动计算机命令行" title="重新启动计算机命令行"></a>重新启动<del>计算机</del>命令行</h4><h4 id="检验是否安装完成"><a href="#检验是否安装完成" class="headerlink" title="检验是否安装完成"></a><a href="#检验是否安装完成" title="检验是否安装完成"></a>检验是否安装完成</h4><p>直接运行cmd命令行，输入g++ -v</p><p><img src="/images/8.jpg" alt="8"></p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a><a href="#参考文档：" title="参考文档："></a>参考文档：</h3><p><a href="http://hi.baidu.com/lmstz/item/d9248feba18497cfbbf37d8b">Mingw32 gcc/g++ 的安装过程</a></p><p><a href="http://wenku.baidu.com/link?url=a1NsXuYLF_yHiCY6TZpvu7ly-LxJBLMcjAd0nsxZwSoKssHx7OS4NDgs4aTCZji0UGtFmrY5q3jROq87EJpcz6XyGt2qNmmUg3uDMwKJDLW">S​u​b​l​i​m​e​_​T​e​x​t​ ​3​搭​建​c​ ​c​+​+​ ​j​a​v​a​语​言​开​发​环​境​教​程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
